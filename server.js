const express = require('express');
const http = require('http');
const socketIo = require('socket.io');
const cors = require('cors');
const path = require('path');
require('dotenv').config();

// ะะผะฟะพัั ะฝะฐัะธั ัะตัะฒะธัะพะฒ
//const TelegramService = require('./src/telegram');
const WhatsAppService = require('./src/whatsapp');
const FacebookService = require('./src/facebook');
const DatabaseService = require('./src/database');
const ChatbotService = require('./src/chatbot');
const TelegramChannelService = require('./src/telegram-channel');

class CentralServer {
  constructor() {
    this.app = express();
    this.server = http.createServer(this.app);
    this.io = socketIo(this.server, {
      cors: {
        origin: "*",
        methods: ["GET", "POST"]
      }
    });
    
    this.activeSessions = new Map();
    this.operators = new Set();
    
    this.setupMiddleware();
    this.setupRoutes();
    this.setupSocket();
    this.initializeServices();
  }

  setupMiddleware() {
    this.app.use(cors());
    this.app.use(express.json());
    this.app.use(express.static(path.join(__dirname, 'public')));
  }

  setupRoutes() {
    // ะะปะฐะฒะฝะฐั ัััะฐะฝะธัะฐ
    this.app.get('/', (req, res) => {
      res.redirect('/operator');
    });

    // API ะดะปั ะฟะพะปััะตะฝะธั ััะฐัะธััะธะบะธ
    this.app.get('/api/stats', (req, res) => {
      res.json({
        activeSessions: this.activeSessions.size,
        channels: {
          whatsapp: Array.from(this.activeSessions.values()).filter(s => s.channel === 'whatsapp').length,
          telegram: Array.from(this.activeSessions.values()).filter(s => s.channel === 'telegram').length,
          facebook: Array.from(this.activeSessions.values()).filter(s => s.channel === 'facebook').length,
          web: Array.from(this.activeSessions.values()).filter(s => s.channel === 'web').length
        }
      });
    });

    // API ะดะปั ะฟะพะปััะตะฝะธั ะฐะบัะธะฒะฝัั ัะตััะธะน
    this.app.get('/api/sessions', (req, res) => {
      const sessions = Array.from(this.activeSessions.entries()).map(([id, session]) => ({
        id,
        ...session,
        lastMessage: session.messages[session.messages.length - 1]
      }));
      res.json(sessions);
    });

    // API ะดะปั ะฟะพะปััะตะฝะธั ะพะฑััะฒะปะตะฝะธะน
    this.app.get('/api/properties', async (req, res) => {
      try {
        const { type, rooms, price_min, price_max } = req.query;
        const properties = await TelegramChannelService.getProperties({ type, rooms, price_min, price_max });
        res.json(properties);
      } catch (error) {
        console.error('ะัะธะฑะบะฐ ะฟะพะปััะตะฝะธั ะพะฑััะฒะปะตะฝะธะน:', error);
        res.status(500).json({ error: 'ะัะธะฑะบะฐ ะฟะพะปััะตะฝะธั ะพะฑััะฒะปะตะฝะธะน' });
      }
    });
  }

  setupSocket() {
    this.io.on('connection', (socket) => {
      console.log('ะะฟะตัะฐัะพั ะฟะพะดะบะปััะธะปัั:', socket.id);
      this.operators.add(socket.id);

      // ะัะฟัะฐะฒะปัะตะผ ัะตะบััะธะต ัะตััะธะธ ะฝะพะฒะพะผั ะพะฟะตัะฐัะพัั
      socket.emit('sessionsUpdate', Array.from(this.activeSessions.entries()));

      // ะะฑัะฐะฑะพัะบะฐ ะฒัะพะดััะธั ัะพะพะฑัะตะฝะธะน
      socket.on('incomingMessage', (data) => {
        this.handleIncomingMessage(data);
      });

      // ะะฟะตัะฐัะพั ะฑะตัะตั ัะตััะธั
      socket.on('operatorTakeOver', (sessionId) => {
        this.operatorTakeOver(sessionId, socket.id);
      });

      // ะกะพะพะฑัะตะฝะธะต ะพั ะพะฟะตัะฐัะพัะฐ
      socket.on('operatorMessage', (data) => {
        this.sendOperatorMessage(data);
      });

      // ะะพะทะฒัะฐั ะบ ะฑะพัั
      socket.on('returnToBot', (sessionId) => {
        this.returnToBot(sessionId);
      });

      socket.on('disconnect', () => {
        console.log('ะะฟะตัะฐัะพั ะพัะบะปััะธะปัั:', socket.id);
        this.operators.delete(socket.id);
      });
    });

    // ะะตะปะฐะตะผ io ะดะพัััะฟะฝัะผ ะณะปะพะฑะฐะปัะฝะพ ะดะปั ัะตัะฒะธัะพะฒ
    global.io = this.io;
  }

  async handleIncomingMessage(data) {
    const { channel, userId, message, userInfo } = data;
    const sessionId = `${channel}_${userId}`;

    console.log(`ะะพะฒะพะต ัะพะพะฑัะตะฝะธะต ะธะท ${channel}:`, message);

    // ะกะพะทะดะฐะตะผ ะธะปะธ ะพะฑะฝะพะฒะปัะตะผ ัะตััะธั
    if (!this.activeSessions.has(sessionId)) {
      this.activeSessions.set(sessionId, {
        channel,
        userId,
        userInfo,
        isOperatorActive: false,
        operatorId: null,
        messages: [],
        createdAt: Date.now(),
        lastActivity: Date.now()
      });
    }

    const session = this.activeSessions.get(sessionId);
    session.messages.push({
      from: 'user',
      text: message,
      timestamp: Date.now()
    });
    session.lastActivity = Date.now();

    // ะกะพััะฐะฝัะตะผ ะฒ ะฑะฐะทั ะดะฐะฝะฝัั
    try {
      await DatabaseService.saveMessage(sessionId, 'user', message);
    } catch (error) {
      console.error('ะัะธะฑะบะฐ ัะพััะฐะฝะตะฝะธั ะฒ ะะ:', error);
    }

    // ะัะปะธ ะพะฟะตัะฐัะพั ะฝะต ะฐะบัะธะฒะตะฝ - ะพัะฒะตัะฐะตั ะฑะพั
    if (!session.isOperatorActive) {
      try {
        const botResponse = await ChatbotService.processMessage(message, sessionId);
        await this.sendToChannel(channel, userId, botResponse);
        
        session.messages.push({
          from: 'bot',
          text: botResponse,
          timestamp: Date.now()
        });

        await DatabaseService.saveMessage(sessionId, 'bot', botResponse);
      } catch (error) {
        console.error('ะัะธะฑะบะฐ ะพะฑัะฐะฑะพัะบะธ ะฑะพัะพะผ:', error);
        const fallbackResponse = 'Sorry, an error occurred. Please try again.';
        await this.sendToChannel(channel, userId, fallbackResponse);
      }
    }

    // ะฃะฒะตะดะพะผะปัะตะผ ะฒัะตั ะพะฟะตัะฐัะพัะพะฒ
    this.io.emit('newMessage', {
      sessionId,
      channel,
      userId,
      message,
      userInfo,
      timestamp: Date.now()
    });
  }

  async sendToChannel(channel, userId, message) {
    console.log(`ะัะฟัะฐะฒะบะฐ ะฒ ${channel}:`, message);
    
    switch (channel) {
      case 'whatsapp':
        return await this.whatsappService.sendMessage(userId, message);
      case 'telegram':
  	console.log('Telegram ะพัะบะปััะตะฝ ะฒัะตะผะตะฝะฝะพ');
 	 return true;
        //return await this.telegramService.sendMessage(userId, message);
      case 'facebook':
        return await this.facebookService.sendMessage(userId, message);
      case 'web':
        return this.io.emit('webMessage', { userId, message });
    }
  }

  operatorTakeOver(sessionId) {
    const session = this.activeSessions.get(sessionId);
    if (session) {
      session.isOperatorActive = true;
      this.io.emit('sessionTakenOver', { sessionId });
      console.log(`ะะฟะตัะฐัะพั ะฒะทัะป ัะตััะธั: ${sessionId}`);
    }
  }

  async sendOperatorMessage(data) {
    const { sessionId, message } = data;
    const session = this.activeSessions.get(sessionId);
    
    if (session && session.isOperatorActive) {
      await this.sendToChannel(session.channel, session.userId, message);
      
      session.messages.push({
        from: 'operator',
        text: message,
        timestamp: Date.now()
      });

      try {
        await DatabaseService.saveMessage(sessionId, 'operator', message);
      } catch (error) {
        console.error('ะัะธะฑะบะฐ ัะพััะฐะฝะตะฝะธั ัะพะพะฑัะตะฝะธั ะพะฟะตัะฐัะพัะฐ:', error);
      }
      
      this.io.emit('operatorMessageSent', { sessionId, message });
    }
  }

  returnToBot(sessionId) {
    const session = this.activeSessions.get(sessionId);
    if (session) {
      session.isOperatorActive = false;
      this.io.emit('sessionReturnedToBot', { sessionId });
      console.log(`ะกะตััะธั ะฒะพะทะฒัะฐัะตะฝะฐ ะฑะพัั: ${sessionId}`);
    }
  }

  async initializeServices() {
    try {
      console.log('ะะฝะธัะธะฐะปะธะทะฐัะธั ัะตัะฒะธัะพะฒ...');
      
      // ะะฝะธัะธะฐะปะธะทะฐัะธั ะฑะฐะทั ะดะฐะฝะฝัั
      await DatabaseService.initialize();
      console.log('โ ะะฐะทะฐ ะดะฐะฝะฝัั ะธะฝะธัะธะฐะปะธะทะธัะพะฒะฐะฝะฐ');
      
      // ะะฝะธัะธะฐะปะธะทะฐัะธั ัะตัะฒะธัะพะฒ
      //this.telegramService = new TelegramService();
      //console.log('โ Telegram ัะตัะฒะธั ัะพะทะดะฐะฝ');
      
      this.whatsappService = new WhatsAppService();
      console.log('โ WhatsApp ัะตัะฒะธั ัะพะทะดะฐะฝ');
      
      this.facebookService = new FacebookService();
      console.log('โ Facebook ัะตัะฒะธั ัะพะทะดะฐะฝ');
      
      // ะะพะฑะฐะฒะปัะตะผ Facebook routes
      this.app.use('/facebook', this.facebookService.getRouter());
      
      // ะะฝะธัะธะฐะปะธะทะฐัะธั WhatsApp
      //await this.whatsappService.initialize();
      //console.log('โ WhatsApp ะบะปะธะตะฝั ะธะฝะธัะธะฐะปะธะทะธัะพะฒะฐะฝ');
      
      // ะะฝะธัะธะฐะปะธะทะฐัะธั Telegram ะบะฐะฝะฐะปะฐ
      await TelegramChannelService.initialize();
      console.log('โ Telegram ะบะฐะฝะฐะป ะธะฝะธัะธะฐะปะธะทะธัะพะฒะฐะฝ');
      
      console.log('๏ฟฝ๏ฟฝ ะัะต ัะตัะฒะธัั ะธะฝะธัะธะฐะปะธะทะธัะพะฒะฐะฝั ััะฟะตัะฝะพ!');
    } catch (error) {
      console.error('โ ะัะธะฑะบะฐ ะธะฝะธัะธะฐะปะธะทะฐัะธะธ ัะตัะฒะธัะพะฒ:', error);
    }
  }

  start() {
    const PORT = process.env.PORT || 3000;
    this.server.listen(PORT, () => {
      console.log(`๐ ะกะตัะฒะตั ะทะฐะฟััะตะฝ ะฝะฐ ะฟะพััั ${PORT}`);
      console.log(`๐จโ๏ฟฝ๏ฟฝ ะะฐะฝะตะปั ะพะฟะตัะฐัะพัะฐ: http://localhost:${PORT}/operator`);
      console.log(`๏ฟฝ๏ฟฝ ะะตะฑ-ัะฐั: http://localhost:${PORT}/webchat`);
    });
  }
}

// ะะฐะฟััะบ ัะตัะฒะตัะฐ
const server = new CentralServer();

server.start();
